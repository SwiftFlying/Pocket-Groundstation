
/*
Notes:
LASEREINHORNBACKFISCH
 */

#define R1 400  // Widerstand 1
#define R2 100  // Widerstand 2

#define Voltagedetect 3.5 // Min. Voltage for Detection

#define note 262  // C4

#define BUTTON1_PIN              2  // Button 1
#define BUTTON2_PIN              3  // Button 2
#define BUTTON3_PIN              4  // Button 3

#define beeppin 9 // Beeper Pin

#define DELAY                    20  // Delay per loop in ms
 
#include "U8glib.h"

U8GLIB_SH1106_128X64 u8g(U8G_I2C_OPT_DEV_0 | U8G_I2C_OPT_FAST);  // Dev 0, Fast I2C / TWI




float voltage;

int lipo;



const uint8_t settings16_bitmap[] PROGMEM = 
{
  // size is 16 x 16
0x42, 0x4D, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 
0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x00, 0x22, 0x22, 
0x22, 0x00, 0x33, 0x33, 0x33, 0x00, 0x44, 0x44, 0x44, 0x00, 0x55, 0x55, 0x55, 0x00, 0x66, 0x66, 
0x66, 0x00, 0x77, 0x77, 0x77, 0x00, 0x88, 0x88, 0x88, 0x00, 0x99, 0x99, 0x99, 0x00, 0xAA, 0xAA, 
0xAA, 0x00, 0xBB, 0xBB, 0xBB, 0x00, 0xCC, 0xCC, 0xCC, 0x00, 0xDD, 0xDD, 0xDD, 0x00, 0xEE, 0xEE, 
0xEE, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x61, 0x15, 0xFF, 0xFF, 0xFF, 0xFF, 0xF6, 
0xCF, 0x40, 0x03, 0xFD, 0x6E, 0xFF, 0xFE, 0x40, 0x24, 0x00, 0x00, 0x32, 0x03, 0xEF, 0xF7, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0xFD, 0x30, 0x00, 0x01, 0x10, 0x00, 0x02, 0xDF, 0xFF, 0x50, 
0x01, 0x9E, 0xEA, 0x10, 0x04, 0xFF, 0x53, 0x00, 0x08, 0xFF, 0xFF, 0xA0, 0x00, 0x35, 0x00, 0x00, 
0x1E, 0xFF, 0xFF, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x1E, 0xFF, 0xFF, 0xF1, 0x00, 0x00, 0x64, 0x10, 
0x08, 0xFF, 0xFF, 0x90, 0x00, 0x46, 0xFF, 0x50, 0x00, 0x8D, 0xD8, 0x10, 0x04, 0xFF, 0xFC, 0x20, 
0x00, 0x01, 0x10, 0x00, 0x02, 0xCF, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0xFF, 0x50, 
0x25, 0x10, 0x00, 0x53, 0x04, 0xEF, 0xFF, 0xF8, 0xDF, 0x40, 0x03, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 
0xFF, 0x71, 0x16, 0xFF, 0xFF, 0xFF, 0x00, 0x00

}
;




const uint8_t DVR16_bitmap[] PROGMEM = 
{
  // size is 16 x 16
0x42, 0x4D, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 
0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x00, 0x22, 0x22, 
0x22, 0x00, 0x33, 0x33, 0x33, 0x00, 0x44, 0x44, 0x44, 0x00, 0x55, 0x55, 0x55, 0x00, 0x66, 0x66, 
0x66, 0x00, 0x77, 0x77, 0x77, 0x00, 0x88, 0x88, 0x88, 0x00, 0x99, 0x99, 0x99, 0x00, 0xAA, 0xAA, 
0xAA, 0x00, 0xBB, 0xBB, 0xBB, 0x00, 0xCC, 0xCC, 0xCC, 0x00, 0xDD, 0xDD, 0xDD, 0x00, 0xEE, 0xEE, 
0xEE, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x88, 0x88, 0x88, 0x88, 0x9F, 0xFF, 0xFC, 0x50, 0x00, 
0x00, 0x00, 0x00, 0x05, 0xFF, 0x81, 0x10, 0x78, 0x87, 0x00, 0x00, 0x01, 0xE4, 0x01, 0x11, 0xFF, 
0xFF, 0x10, 0x00, 0x01, 0xD0, 0x01, 0x01, 0xEF, 0xFE, 0x10, 0x00, 0x01, 0xD1, 0x00, 0x01, 0xFF, 
0xFF, 0x17, 0x97, 0x01, 0xD0, 0x00, 0x00, 0x78, 0x87, 0x07, 0x97, 0x01, 0xE4, 0x00, 0x50, 0x00, 
0x00, 0x00, 0x00, 0x05, 0xFF, 0x80, 0xF9, 0x88, 0x88, 0x70, 0x00, 0x9F, 0xFF, 0xFC, 0xFF, 0xFF, 
0xFF, 0xFB, 0x1A, 0xFF, 0xFF, 0xFF, 0xFF, 0x86, 0x66, 0x66, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0x86, 
0x66, 0x67, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFE, 0xEF, 0xFF, 0xFF, 0xFF, 0x00, 0x00 
}
;


const uint8_t DVRstatus8_bitmap[] PROGMEM = 
{
  // size is 8  x 8
0x42, 0x4D, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 
0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x00, 0x22, 0x22, 
0x22, 0x00, 0x33, 0x33, 0x33, 0x00, 0x44, 0x44, 0x44, 0x00, 0x55, 0x55, 0x55, 0x00, 0x66, 0x66, 
0x66, 0x00, 0x77, 0x77, 0x77, 0x00, 0x88, 0x88, 0x88, 0x00, 0x99, 0x99, 0x99, 0x00, 0xAA, 0xAA, 
0xAA, 0x00, 0xBB, 0xBB, 0xBB, 0x00, 0xCC, 0xCC, 0xCC, 0x00, 0xDD, 0xDD, 0xDD, 0x00, 0xEE, 0xEE, 
0xEE, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF1, 0x11, 0x11, 0x1F, 0x1F, 0xFF, 0xFF, 0xF1, 0x1F, 0xF1, 
0x1F, 0xF1, 0x1F, 0x11, 0x11, 0xF1, 0x1F, 0x11, 0x11, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xFF, 
0xFF, 0xF1, 0xF1, 0x11, 0x11, 0x1F, 0x00, 0x00
}
;


void pause()
{
  beep_criticalt(20);
  while (1);
}

void setup()  
{

  pinMode(BUTTON1_PIN, INPUT_PULLUP);
  pinMode(BUTTON2_PIN, INPUT_PULLUP);
  pinMode(BUTTON3_PIN, INPUT_PULLUP);

  Serial.begin(9600);
  

  if ( u8g.getMode() == U8G_MODE_R3G3B2 ) {
    u8g.setColorIndex(255);     // white
  }
  else if ( u8g.getMode() == U8G_MODE_GRAY2BIT ) {
    u8g.setColorIndex(3);         // max intensity
  }
  else if ( u8g.getMode() == U8G_MODE_BW ) {
    u8g.setColorIndex(1);         // pixel on
  }
  else if ( u8g.getMode() == U8G_MODE_HICOLOR ) {
    u8g.setHiColorByRGB(255, 255, 255);
  }

  delay(100);
  
  voltagetest();
  if (voltage > (Voltagedetect * 5.0))
  {
    lipo = 5;
    beep_x(lipo);
  }
  else if (voltage > (Voltagedetect * 4.0))
  {
    lipo = 4;
    beep_x(lipo);
  }
  else if (voltage > (Voltagedetect * 3.0))
  {
    lipo = 3;
    beep_x(lipo);
  }
  else if (voltage > (Voltagedetect * 2.0))
  {
    lipo = 2;
    beep_x(lipo);
  }
  else
  {
    pause();
  }
}




void voltagetest() 
{
  int sensorValue = analogRead(A0);   // read the input on analog pin 0:
  voltage = sensorValue * (5.0 / 1023.0) * ((R1+R2)/R2);   // Convert the analog reading (which goes from 0 - 1023) to a voltage, considering the voltage divider:
 // Serial.println(voltage);   // print out the value you read:


  if (voltage > 4.9) 
  { // case if voltage is above 4.9v
    u8g.drawBox(114, 5, 2, 2);
    u8g.drawBox(117, 5, 2, 2);
    u8g.drawBox(120, 5, 2, 2);
    u8g.drawFrame(112, 5 - 2, 12, 6);
    u8g.drawBox(124, 5, 1, 2);
  }

  else if (voltage < 3.9 && voltage > 3.4) 
  { // case if voltage is below 3.4
    Serial.print("Battery half");
    u8g.drawBox(114, 5, 2, 2);
    u8g.drawBox(117, 5, 2, 2);
    u8g.drawFrame(112, 5 - 2, 12, 6);
    u8g.drawBox(124, 5, 1, 2);
  }

  else if (voltage < 3.4) 
  { // case if voltage is below 3.4
    beep_criticalt(225);
    Serial.print("Battery critical");
    u8g.drawFrame(112, 5 - 2, 12, 6);
    u8g.drawBox(124, 5, 1, 2);

  }

  else 
  {
    u8g.drawBox(114, 5, 2, 2);
    u8g.drawBox(117, 5, 2, 2);
    u8g.drawBox(120, 5, 2, 2);
    u8g.drawFrame(112, 5 - 2, 12, 6);
    u8g.drawBox(124, 5, 1, 2);
  }

  // graphic commands to redraw the complete screen should be placed here
  u8g.setFont(u8g_font_5x7);
  u8g.setPrintPos(0, 9);
  u8g.print("Battery Status");
  u8g.setFont(u8g_font_5x7);
  u8g.setPrintPos(99, 9);
  u8g.print(lipo);
   u8g.setFont(u8g_font_5x7);
  u8g.setPrintPos(105, 9);
  u8g.print("S");
  u8g.setFont(u8g_font_8x13B);
  u8g.setPrintPos(0, 24);
  u8g.print(voltage);

  u8g.drawBitmapP( 10, 50, 1, 16, settings16_bitmap);
  u8g.drawBitmapP( 30, 50, 1, 16, DVR16_bitmap);
  u8g.drawBitmapP( 48, 50, 1, 8, DVRstatus8_bitmap);

  delay(10);
}




void loop()  {
 // handle buttons
    
    int buttonState1 = !digitalRead(BUTTON1_PIN); // pin low -> pressed
    if (buttonState1 == 1)
    {
     beep(1);
     Serial.print("Button1 pressed");
    }
    
    
    int buttonState2 = !digitalRead(BUTTON2_PIN); // pin low -> pressed
    if (buttonState2 == 1)
    {
     beep(1);
     Serial.print("Button2 pressed");
    }

    
    int buttonState3 = !digitalRead(BUTTON3_PIN); // pin low -> pressed
    if (buttonState3 == 1)
    {
     beep(1);
     Serial.print("Button3 pressed");
    }
    

    
  u8g.firstPage();
  do {
    voltagetest();
  }
  while (u8g.nextPage());
  delay(DELAY);
}

// Beep-Stuff

void beep(unsigned char delayms) 
{
  tone(beeppin, note, 10);  // 100ms beep (C4 Tone)
}

void beep_long(unsigned char delayms) 
{
  tone(beeppin, note, 2000); // 2000ms beep (C4 Tone)
}

void beep_warning(unsigned char delayms) 
{
  tone(beeppin, note, 200);  // 200ms beep (C4 Tone)
  delay(400);
  tone(beeppin, note, 200);  // 200ms beep (C4 Tone)
}

void beep_criticalt(unsigned char delayms) 
{
  tone(beeppin, note, 400);  // 400ms beep (C4 Tone)
  delay(800);
  tone(beeppin, note, 400);  // 400ms beep (C4 Tone)
  delay(800);
  tone(beeppin, note, 400);  // 400ms beep (C4 Tone)
}

void beep_x(byte b)
{
  for (int i = 1; i <= b; i++)
  {
    tone(beeppin, note, 200);
    delay(400);
  }
}









